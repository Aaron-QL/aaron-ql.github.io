<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="pthread," />










<meta name="description" content="线程概念线程包含有表示执行环境所必须的信息，包括线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。 线程标识每个线程有一个线程ID，进程ID在整个系统中是唯一的，但线程ID不同，线程ID只有它所属的进程上下文中才有意义。 1234int pthre">
<meta property="og:type" content="article">
<meta property="og:title" content="《APUE》ch11——线程">
<meta property="og:url" content="https://aaron-ql.github.io/articles/%E3%80%8AAPUE%E3%80%8Bch11%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Code Your Ambition">
<meta property="og:description" content="线程概念线程包含有表示执行环境所必须的信息，包括线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。 线程标识每个线程有一个线程ID，进程ID在整个系统中是唯一的，但线程ID不同，线程ID只有它所属的进程上下文中才有意义。 1234int pthre">
<meta property="og:locale">
<meta property="og:image" content="https://picbed-1253674052.cos.ap-beijing.myqcloud.com/uPic/dyyrAR.png">
<meta property="og:image" content="https://picbed-1253674052.cos.ap-beijing.myqcloud.com/uPic/02TOYp.png">
<meta property="og:image" content="https://picbed-1253674052.cos.ap-beijing.myqcloud.com/uPic/CARolz.png">
<meta property="article:published_time" content="2019-12-20T14:19:30.000Z">
<meta property="article:modified_time" content="2022-03-01T11:45:12.000Z">
<meta property="article:author" content="Aaron Qin">
<meta property="article:tag" content="pthread">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://picbed-1253674052.cos.ap-beijing.myqcloud.com/uPic/dyyrAR.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://aaron-ql.github.io/articles/《APUE》ch11——线程/"/>





  <title>《APUE》ch11——线程 | Code Your Ambition</title>
  




<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-ZV2QP61MNB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-ZV2QP61MNB');
</script>






<meta name="generator" content="Hexo 5.4.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Code Your Ambition</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://aaron-ql.github.io/articles/%E3%80%8AAPUE%E3%80%8Bch11%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code Your Ambition">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《APUE》ch11——线程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-20T22:19:30+08:00">
                2019-12-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AAPUE%E3%80%8B/" itemprop="url" rel="index">
                    <span itemprop="name">《APUE》</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/articles/%E3%80%8AAPUE%E3%80%8Bch11%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="articles/《APUE》ch11——线程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>线程包含有表示执行环境所必须的信息，包括线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符。</p>
<h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>每个线程有一个线程ID，进程ID在整个系统中是唯一的，但线程ID不同，线程ID只有它所属的进程上下文中才有意义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>; <span class="comment">//比较两个线程是否相等</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">//获取调用线程的线程ID</span></span><br></pre></td></tr></table></figure>
<p><img src="https://picbed-1253674052.cos.ap-beijing.myqcloud.com/uPic/dyyrAR.png" alt="dyyrAR"></p>
<span id="more"></span>

<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>每个进程只有一个控制线程。线程创建时不保证哪个线程会先运行。新创建的线程可以访问进程的地址空间，并继承调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">pthread_t</span> *<span class="keyword">restrict</span> tidp, <span class="comment">//线程ID</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *<span class="keyword">restrict</span> attr, <span class="comment">//线程属性</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">void</span> *(*start_rtn)(<span class="keyword">void</span> *), <span class="comment">//新线程从start_rtn开始执行</span></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">void</span> *<span class="keyword">restrict</span> arg <span class="comment">// start_rnt函数的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<!--more-->

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> new_tid;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_ids</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid = getppid();</span><br><span class="line">    <span class="keyword">pthread_t</span> tid = pthread_self();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s pid %lu tid %lu (0x%lx)\n&quot;</span>, s, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) pid, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) tid, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_function</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print_ids(<span class="string">&quot;new thread : &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    err = pthread_create(&amp;new_tid, <span class="literal">NULL</span>, thread_function, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(err, <span class="string">&quot;can&#x27;t create thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_ids(<span class="string">&quot;main thread: &quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实例有两个特别之处，主线程与新线程之间存在竞争：</p>
<ol>
<li>主线程如果不休眠，可能新线程还没有机会执行，整个进程就终止了</li>
<li>新线程通过调用pthread_self获取自身的线程ID，而不是从共享内存读出或从线程的启动例程中以参数形式接收，因为那样并不安全。</li>
</ol>
<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>如果进程中的任意线程调用了exit、_Exit、或者_exit，那么整个进程就会终止。<br>单个线程可以在不终止整个进程的情况下，以以下三种方式停止它的控制流：</p>
<ol>
<li>线程可以简单地从启动例程中返回，返回值是线程的退出码。</li>
<li>线程可以被同一进程中的其他线程取消。</li>
<li>线程调用pthread_exit。</li>
</ol>
<h3 id="使用pthread-exit退出"><a href="#使用pthread-exit退出" class="headerlink" title="使用pthread_exit退出"></a>使用<code>pthread_exit</code>退出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span> *rval_ptr)</span></span>; <span class="comment">//单个线程退出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **rval_ptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>pthread_join</code>相当于进程里的<code>waitpid</code>,调用线程将一直阻塞，直到指定线程调用<code>pthread_exit</code>退出、从启动例程中返回或者取消。reval_ptr是无类型指针，包含返回状态，如果不感兴趣的话可以设为NULL。</p>
<p>下面展示用自动变量（分配在栈上）作为pthread_exit的参数时出现的问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">const</span> struct foo *fp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  structure at 0x%lx\n&quot;</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  foo.a = %d\n&quot;</span>, fp-&gt;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  foo.b = %d\n&quot;</span>, fp-&gt;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  foo.c = %d\n&quot;</span>, fp-&gt;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  foo.d = %d\n&quot;</span>, fp-&gt;d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func1</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">foo</span> =</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    print_foo(<span class="string">&quot;thread 1: &quot;</span>, &amp;foo);</span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *) &amp;foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> * <span class="title">foo_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func1, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_join(tid1, (<span class="keyword">void</span>*)&amp;foo_ptr) != <span class="number">0</span>) &#123;</span><br><span class="line">        err_sys(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    print_foo(<span class="string">&quot;main: &quot;</span>, foo_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//在macOS X上运行：</span><br><span class="line">$ ./a.out  </span><br><span class="line">thread 1:   structure at 0x70000f3e9f90</span><br><span class="line">  foo.a = 1</span><br><span class="line">  foo.b = 2</span><br><span class="line">  foo.c = 3</span><br><span class="line">  foo.d = 4</span><br><span class="line">main:   structure at 0x70000f3e9f90</span><br><span class="line">[1]    27204 segmentation fault  ./a.out</span><br></pre></td></tr></table></figure>
<p>可以看到，当主线程访问这个结构时,结构的内容（在线程tid1的栈上分配的）已经改变了。父进程试图访问已退出的第一个线程传给它的结构时，内存不再有效，这时得到的是SIGSEGV信号。为了解决这个问题，可以使用全局结构，或者用malloc函数分配结构。</p>
<h3 id="使用pthread-cancel取消线程"><a href="#使用pthread-cancel取消线程" class="headerlink" title="使用pthread_cancel取消线程"></a>使用<code>pthread_cancel</code>取消线程</h3><p>线程可以通过<code>pthread_cancel</code>函数来请求取消同一进程中的其他线程。<br>线程可以注册退出时调用的 <em>线程清理程序（thread cleanup handler）</em> ，这与进程的<code>atexit</code>函数类似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*rnt)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="线程与进程的原语比较"><a href="#线程与进程的原语比较" class="headerlink" title="线程与进程的原语比较"></a>线程与进程的原语比较</h2><p><img src="https://picbed-1253674052.cos.ap-beijing.myqcloud.com/uPic/02TOYp.png" alt="02TOYp"></p>
<h2 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h2><p>默认情况下，线程的终止状态会保存直到对该线程调用<code>pthread_join</code>。如果线程已经被<code>分离</code>,线程的底层存储资源可以在线程终止时立即被回收。在线程被分离后，我们不能用<code>pthread_join</code>函数等待它的终止状态，这会产生未定义的行为。可以调用<code>pthread_detach</code>分离线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>当进程中存在多个线程时，每个线程使用的变量可能会被其他线程读取或修改，为解决这个问题，就必须使用锁。<br><img src="https://picbed-1253674052.cos.ap-beijing.myqcloud.com/uPic/CARolz.png" alt="CARolz"></p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>互斥量本质是一把锁，在访问共享资源前加锁（对互斥量进行设置），完成后解锁（释放互斥量）。涉及以下函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量初始化，也可以直接用 PTHREAD_MUTEX_INITIALIZER 常量静态初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反初始化，释放互斥量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对互斥量加锁，如果已经上锁，则调用线程将阻塞直至互斥量被解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对互斥量尝试加锁，成功返回0，失败不阻塞，直接返回EBUSY</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对互斥量解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>


<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><h4 id="造成死锁的原因"><a href="#造成死锁的原因" class="headerlink" title="造成死锁的原因"></a>造成死锁的原因</h4><p>如果线程对同一个互斥量加锁两次，会造成死锁；两个线程各自锁住一个互斥量，并等待对方解锁它持有的互斥量，也会造成死锁。</p>
<h4 id="避免死锁的方法："><a href="#避免死锁的方法：" class="headerlink" title="避免死锁的方法："></a>避免死锁的方法：</h4><ul>
<li>可以通过仔细控制互斥量加锁的顺序来避免死锁发生（按相同的顺序加锁）</li>
<li>使用<code>pthread_mutex_trylock</code>尝试加锁，如果失败则先释放已有的锁，做好清理工作，过段时间再试</li>
</ul>
<p>下面的例子说明了使用两把锁时如何进行简化设计，避免死锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NHASH 29</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HASH(id) (((unsigned long) id) % NNHASH)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> *<span class="title">foo_buffer</span>[<span class="title">NHASH</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> hash_lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function">struct foo *<span class="title">foo_alloc</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash_id = HASH(id);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> * <span class="title">foo_ptr</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct foo));</span><br><span class="line">    <span class="keyword">if</span> (foo_ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo_ptr-&gt;id = id;</span><br><span class="line">    foo_ptr-&gt;count = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;foo_ptr-&gt;lock);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;ash_lock);</span><br><span class="line">    foo_ptr-&gt;next = foo_buffer[hash_id];</span><br><span class="line">    foo_buffer[hash_id] = foo_ptr;</span><br><span class="line">    pthread_mutex_unlock(&amp;hash_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> foo_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_hold</span><span class="params">(struct foo *foo_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;foo_ptr-&gt;lock);</span><br><span class="line">    foo_ptr-&gt;count++;</span><br><span class="line">    pthread_mutex_unlock(&amp;foo_ptr-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct foo *<span class="title">foo_find</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> * <span class="title">foo_ptr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> hash_id = HASH(id);</span><br><span class="line">    pthread_mutex_lock(&amp;hash_lock);</span><br><span class="line">    <span class="keyword">for</span> (foo_ptr = foo_buffer[hash_id]; foo_ptr != <span class="literal">NULL</span>; foo_ptr = foo_ptr-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (foo_ptr-&gt;id == id) &#123;</span><br><span class="line">            foo_hold(foo_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;hash_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> foo_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_release</span><span class="params">(struct foo *foo_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;hash_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (--foo_ptr-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> hash_id = HASH(foo_ptr-&gt;id);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">foo</span> * <span class="title">foo_temp</span> =</span> foo_buffer[hash_id];</span><br><span class="line">        <span class="keyword">if</span> (foo_temp == foo_ptr) &#123;</span><br><span class="line">            foo_buffer[hash_id] = foo_ptr-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (foo_temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (foo_temp-&gt;next == foo_ptr) &#123;</span><br><span class="line">                    foo_temp-&gt;next = foo_ptr-&gt;next;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;hash_lock);</span><br><span class="line">        pthread_mutex_destroy(&amp;foo_ptr-&gt;lock);</span><br><span class="line">        <span class="built_in">free</span>(foo_ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;hash_lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>多线程的软件设计要注意锁的粒度：如果锁的粒度太粗，就会出现多线程阻塞等待相同的锁，这可能并不能改善并发性；如果锁的粒度太细，那么过多的锁开销会使系统性能受影响，而且代码变得复杂。作为一个程序员，需要在满足锁需求的情况下，在代码复杂性和性能之间找到正确的平衡。</strong></p>
<h4 id="带有超时的互斥量"><a href="#带有超时的互斥量" class="headerlink" title="带有超时的互斥量"></a>带有超时的互斥量</h4><p>函数 pthread_mutex_timedlock，加锁时设置一个愿意等待的绝对时间，超时后放弃加锁，返回错误码ETIMEDOUT。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁与互斥量类似，但允许更高的并行性。非常适合于对数据结构读的次数远大于写的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//锁初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> * <span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destory</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">//加读锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">//加写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">//尝试加读锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">//尝试加写锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面的例子通过读写锁实现了一个多线程的作业请求队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">job</span> &#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> * <span class="title">prevent</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> * <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> * <span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">pthread_rwlock_t</span> lock;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">queue_init</span><span class="params">(struct <span class="built_in">queue</span> *queue_ptr)</span> </span>&#123;</span><br><span class="line">    queue_ptr-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">    queue_ptr-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> pthread_rwlock_init(&amp;queue_ptr-&gt;lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">job_insert</span><span class="params">(struct <span class="built_in">queue</span> *queue_ptr, struct job *job_ptr)</span> </span>&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;queue_ptr-&gt;lock);</span><br><span class="line"></span><br><span class="line">    job_ptr-&gt;next = queue_ptr-&gt;head;</span><br><span class="line">    job_ptr-&gt;prevent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (queue_ptr-&gt;head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        queue_ptr-&gt;tail = job_ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue_ptr-&gt;head-&gt;prevent = job_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    queue_ptr-&gt;head = job_ptr;</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_unlock(&amp;queue_ptr-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">job_append</span><span class="params">(struct <span class="built_in">queue</span> *queue_ptr, struct job * job_ptr)</span> </span>&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;queue_ptr-&gt;lock);</span><br><span class="line"></span><br><span class="line">    job_ptr-&gt;prevent = queue_ptr-&gt;tail;</span><br><span class="line">    job_ptr-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (queue_ptr-&gt;tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        queue_ptr-&gt;head = job_ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue_ptr-&gt;tail-&gt;next = job_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    queue_ptr-&gt;tail = job_ptr;</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_unlock(&amp;queue_ptr-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">job_remove</span><span class="params">(struct <span class="built_in">queue</span> *queue_ptr, struct job *job_ptr)</span> </span>&#123;</span><br><span class="line">    pthread_rwlock_wrlock(&amp;queue_ptr-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (job_ptr == queue_ptr-&gt;head) &#123;</span><br><span class="line">        queue_ptr-&gt;head = job_ptr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (queue_ptr-&gt;tail == job_ptr) &#123;</span><br><span class="line">            queue_ptr-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            queue_ptr-&gt;head-&gt;prevent = job_ptr-&gt;prevent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (job_ptr == queue_ptr-&gt;tail) &#123;</span><br><span class="line">        queue_ptr-&gt;tail = job_ptr-&gt;prevent;</span><br><span class="line">        job_ptr-&gt;prevent-&gt;next = job_ptr-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        job_ptr-&gt;prevent-&gt;next = job_ptr-&gt;next;</span><br><span class="line">        job_ptr-&gt;next-&gt;prevent = job_ptr-&gt;prevent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_unlock(&amp;queue_ptr-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct job *<span class="title">job_find</span><span class="params">(struct <span class="built_in">queue</span> *queue_ptr, <span class="keyword">pthread_t</span> tid)</span> </span>&#123;</span><br><span class="line">    pthread_rwlock_rdlock(&amp;queue_ptr-&gt;lock);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job</span> * <span class="title">job_ptr</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (job_ptr = queue_ptr-&gt;head; job_ptr != <span class="literal">NULL</span>; job_ptr = job_ptr-&gt;next) &#123;</span><br><span class="line">        <span class="comment">//比较线程ID时使用pthread_equal函数</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_equal(job_ptr-&gt;id, tid)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_rwlock_unlock(&amp;queue_ptr-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> job_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="带有超时的读写锁"><a href="#带有超时的读写锁" class="headerlink" title="带有超时的读写锁"></a>带有超时的读写锁</h4><p>函数<code>pthread_rwlock_timedrdlock</code>和<code>pthread_rwlock_timedwdlock</code>提供带有超时的加锁功能，避免在获取锁时永久阻塞。</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。</p>
<p>条件变量本身是由互斥量保护的。线程在改变条件状态之前必须先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种改变，因为互斥量必须在锁定以后才能计算条件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//初始化条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destory</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等待条件变量变为真</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> tsptr</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知线程条件已满足。至少能唤醒一个等待该条件的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒所有</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>
<p>传递给<code>pthread_cond_wait</code>的互斥量对条件进行保护。调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量解锁。这就关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道，这样线程就不会错过条件的任何变化。<code>pthread_cond_wait</code>返回时，互斥量再次被锁住。</p>
<h4 id="多线程消息队列"><a href="#多线程消息队列" class="headerlink" title="多线程消息队列"></a>多线程消息队列</h4><p>下面的例子用多线程及条件变量实现了消息队列，展示了如何使用条件变量和互斥量对线程进行同步。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> * <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">msg_queue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span> queue_ready = PTHREAD_COND_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> queue_block = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue_msg</span><span class="params">(struct msg *msg_ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;message enqueue: %d\n&quot;</span>, msg_ptr-&gt;id);</span><br><span class="line">    pthread_mutex_lock(&amp;queue_block);</span><br><span class="line"></span><br><span class="line">    msg_ptr-&gt;next = msg_queue;</span><br><span class="line">    msg_queue = msg_ptr;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;queue_block);</span><br><span class="line"></span><br><span class="line">    pthread_cond_signal(&amp;queue_ready);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_msg</span><span class="params">(<span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> * <span class="title">msg_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;queue_block);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (msg_queue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;queue_ready, &amp;queue_block);</span><br><span class="line">        &#125;</span><br><span class="line">        msg_ptr = msg_queue;</span><br><span class="line">        msg_queue = msg_queue-&gt;next;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;queue_block);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//consume message</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s consume message: %d\n&quot;</span>, name, msg_ptr-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct msg *<span class="title">msg_init</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> * <span class="title">msg_ptr</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct msg));</span><br><span class="line">    <span class="keyword">if</span> (msg_ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg_ptr-&gt;id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> msg_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func1</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    process_msg(<span class="string">&quot;thread1&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_func2</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    process_msg(<span class="string">&quot;thread2&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func1, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;tid2, <span class="literal">NULL</span>, thread_func2, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> * <span class="title">msg_ptr</span> =</span> msg_init(i);</span><br><span class="line">        enqueue_msg(msg_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>条件变量(cond)是在多线程程序中用来实现”等待–》唤醒”逻辑常用的方法。条件变量利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：一个线程等待”条件变量的条件成立”而挂起；另一个线程使“条件成立”。为了防止竞争，条件变量的使用总是和一个互斥锁结合在一起。线程在改变条件状态前必须首先锁住互斥量，函数<code>pthread_cond_wait</code>把自己放到等待条件的线程列表上，然后对互斥锁解锁(这两个操作是原子操作)。在函数返回时，互斥量再次被锁住。</p>
<h4 id="那为什么有互斥锁，还需要条件变量？"><a href="#那为什么有互斥锁，还需要条件变量？" class="headerlink" title="那为什么有互斥锁，还需要条件变量？"></a>那为什么有互斥锁，还需要条件变量？</h4><p>因为：互斥锁和条件变量所解决的，是不同的问题，不同的场景。</p>
<p>互斥锁解决的是在 shared memory space 模型下，多个线程对同一个全局变量的访问的竞争问题(惊群效应)。由于一些常用写操作的非原子性（从内存中读进寄存器，修改，如果其他线程完成了对这个变量的修改，则旧的修改就被覆盖，等等问题），必须保证同一时间只有一个线程在进行写操作。这就涉及到了互斥锁，将临界区的操作锁起来，保证只有一个线程在进行操作。多个线程在等待同一把锁的时候，按照 FIFO 组织队列，当锁被释放时，队头线程获得锁（由操作系统管理，具体不表）。没有获得锁的线程继续被 block，换言之，它们是因为没有获得锁而被 block。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁与互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。自旋锁适用与以下情况：锁被持有的时间短，而且线程并不希望在重新调度上话费太多成本。当线程自旋等待锁变为可用时，CPU不能做其他事情，这是它只能被持有一小段时间的原因，超过时间分片后会被CPU强行切换。</p>
<p>自旋锁在非抢占式内核中非常有用，但在用户层，自旋锁不是非常有用，除非运行在不允许抢占的实时调度类中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock, <span class="keyword">int</span> pshared)</span></span>; <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>; <span class="comment">// 反初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>; <span class="comment">// 加锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>; <span class="comment">// 尝试加锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>; <span class="comment">// 解锁</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h3><p>屏障是用户协调多个线程并行工作的同步机制。它允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。屏障允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出，所有的线程到达屏障后可以接着工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">pthread_barrier_t</span> *<span class="keyword">restrict</span> barrier,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span> *<span class="keyword">restrict</span> attr,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">unsigned</span> <span class="keyword">int</span> count</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反初始化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表明线程已完成工作，等所有其他线程赶上来</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(<span class="keyword">pthread_barrier_t</span> *barrier)</span></span>;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.png" alt=" 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/pthread/" rel="tag"># pthread</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/articles/%E5%B7%A5%E4%BD%9C%E5%BF%83%E5%BE%97%E6%80%BB%E7%BB%93/" rel="next" title="工作心得总结">
                <i class="fa fa-chevron-left"></i> 工作心得总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/articles/%E3%80%8AAPUE%E3%80%8Bch12%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/" rel="prev" title="《APUE》ch12——线程控制">
                《APUE》ch12——线程控制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a target="_blank" rel="noopener" href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="">
              
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index%202.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index%202.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Aaron-QL" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:aka.qin@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://coolshell.cn/" title="coolshell" target="_blank">coolshell</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://draveness.me/" title="draveness" target="_blank">draveness</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://morven.life/" title="Morven" target="_blank">Morven</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://strikefreedom.top/" title="潘少" target="_blank">潘少</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://colobu.com/" title="鸟窝" target="_blank">鸟窝</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://ctimbai.github.io/" title="猿大白" target="_blank">猿大白</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://eddycjy.com/" title="煎鱼" target="_blank">煎鱼</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lessisbetter.site/" title="大彬" target="_blank">大彬</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://tiancaiamao.gitbooks.io/go-internals/content/zh/" title="深入解析GO" target="_blank">深入解析GO</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">线程概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%87%E8%AF%86"><span class="nav-number">2.</span> <span class="nav-text">线程标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">3.</span> <span class="nav-text">线程创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">4.</span> <span class="nav-text">线程终止</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8pthread-exit%E9%80%80%E5%87%BA"><span class="nav-number">4.1.</span> <span class="nav-text">使用pthread_exit退出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8pthread-cancel%E5%8F%96%E6%B6%88%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">使用pthread_cancel取消线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8E%9F%E8%AF%AD%E6%AF%94%E8%BE%83"><span class="nav-number">5.</span> <span class="nav-text">线程与进程的原语比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB"><span class="nav-number">6.</span> <span class="nav-text">线程分离</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">7.</span> <span class="nav-text">线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">7.1.</span> <span class="nav-text">互斥量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">7.2.</span> <span class="nav-text">避免死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%A0%E6%88%90%E6%AD%BB%E9%94%81%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">7.2.1.</span> <span class="nav-text">造成死锁的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">7.2.2.</span> <span class="nav-text">避免死锁的方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89%E8%B6%85%E6%97%B6%E7%9A%84%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">7.2.3.</span> <span class="nav-text">带有超时的互斥量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">7.3.</span> <span class="nav-text">读写锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89%E8%B6%85%E6%97%B6%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">7.3.1.</span> <span class="nav-text">带有超时的读写锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">7.4.</span> <span class="nav-text">条件变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">7.4.1.</span> <span class="nav-text">多线程消息队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%8C%E8%BF%98%E9%9C%80%E8%A6%81%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%9F"><span class="nav-number">7.4.2.</span> <span class="nav-text">那为什么有互斥锁，还需要条件变量？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">7.5.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%8F%E9%9A%9C"><span class="nav-number">7.6.</span> <span class="nav-text">屏障</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Aaron Qin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://aaron-ql.github.io/articles/%E3%80%8AAPUE%E3%80%8Bch11%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B/';
          this.page.identifier = 'articles/《APUE》ch11——线程/';
          this.page.title = '《APUE》ch11——线程';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
